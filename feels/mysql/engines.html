<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>数据库引擎</title>
</head>
<body>
<pre>
    参考博客地址：https://www.cnblogs.com/sunsky303/p/8274586.html
    show engines; 查看支持的类型
    存储引擎主要有： 1. MyIsam , 2. InnoDB, 3. Memory, 4. Blackhole, 5. CSV, 6. Performance_Schema, 7. Archive, 8. Federated , 9 Mrg_Myisam

    一、InnoDB:（默认）
    一个事务型存储引擎，又行级锁定跟外键约束。
    提供对数据ACID事务的支持，实现四种隔离级别（详见AboutMySQL.html）,支持行级锁与外键约束，设计目标是 处理大容量数据系统。本身是基于MySQL后台的完整数据库系统。
    在mysql运行时，innodb会建立缓冲池，用来缓冲数据跟索引，但是不支持FULLTEXT类型的索引，没有保存行数，使用select count(*)时，会进行全表扫描，
    当需要使用事务时，该引擎首选，由于锁的颗粒度小（行级），写操作时不会锁表，并发度高时，会提升效率，但也不是绝对的，当不知道sql的扫描范围，就会进行锁表。
    适用场景：
    1.经常更新的表，适用于处理高并发的更新请求。
    2.支持事务
    3.可从bin-log中恢复。
    4.外键约束（只有它支持）
    5.支持自动增加类属性
    官方解释：
    1.Innodb给mysql支持提交，回滚和崩溃恢复能力的事务安全（ACID）
    2.Innodb锁定在行级，给SELECT语句提供了一个雷系oracle分格的非锁定读
    3.Innodb支持外键，在sql查询中，可以将innodb类型的表联合查询
    4.Innodb是为处理巨大数据量时的最大性能设计，它的CPU效率可能是任何其它基于磁盘的关系数据库引擎所不能匹敌的。
    5.Innodb用在需要高性能的大型数据库上。
    ACID：
    A：Atomicity，事务的原子性：指的是一个事务要么执行成功，要么执行失败，不会只执行一半，例如取钱，你刷了卡不给你钱，就不行的。
    C：Consistency：事务的一致性，一个事务执行之前与之后，是一致的，流入转账，他的总额时不变的
    I：Isolation：隔离性/独立性，事物之间相互隔离，不会交叉执行，这样会导致数据不一致。
    D：Durability：持久性，事务执行成功后，对数据的影响时持久性的，不会无故更改。
    二、Mylasm
    mysql的默认引擎，但他没有支持事务，也不支持行级锁与外键，当插入与更新数据时，会锁全表，效率更低
    1）不支持事务的设计，但是并不代表着有事务操作的项目不能用MyIsam存储引擎，可以在service层进行根据自己的业务需求进行相应的控制。
    2）不支持外键的表设计。
    3）查询速度很快，如果数据库insert和update的操作比较少的话比较适用。
    4）整天 对表进行加锁的场景。
    5）MyISAM极度强调快速读取操作。
    6）MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。
    缺点：
    就是不能在表损坏后恢复数据。（是不能主动恢复）

    虽然速度上MyISAM快，但是增删改是涉及事务安全的，所以InnoDB相对好很多

    效果对比总述：
    1.事务。MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持，提供事务支持已经外部键等高级数据库功能。
        就是说在不确定的范围时，InnoDB还是会锁表的。
    2.性能主题。MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快。
    3.行数保存。InnoDB 中不保存表的具体行数，也就是说，执行select count() fromtable时，InnoDB要扫描一遍整个表来计算有多少行，
    但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时，两种表的操作是一样的。
    4.索引存储。对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。
    MyISAM支持全文索引（FULLTEXT）、压缩索引，InnoDB不支持
    5.锁的支持。**MyISAM只支持表锁。InnoDB支持表锁、行锁 行锁大幅度提高了多用户并发操作的新能。
    但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的
    6.服务器数据备份。InnoDB必须导出SQL来备份，LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，
    导入数据后再改成InnoDB表，但是对于使用的额外的InnoDB特性(例如外键)的表不适用。

    使用场景推荐
    1）可靠性高或者要求事务处理，则使用InnoDB。这个是必须的。
    2）表更新和查询都相当的频繁，并且表锁定的机会比较大的情况指定InnoDB数据引擎的创建。
    对比之下，MyISAM的使用场景：
    1）做很多count的计算的。如一些日志，调查的业务表。
    2）插入修改不频繁，查询非常频繁的。

    （1）MyIASM引擎的索引结构：
        MyISAM索引结构: MyISAM索引用的B+ tree来储存数据，MyISAM索引的指针指向的是键值的地址，地址存储的是数据。
        B+Tree的数据域存储的内容为实际数据的地址，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的非聚集索引。
        因此，过程为： MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，根据data域的值去读取相应数据记录。
    （2）InnoDB引擎的索引结构：
        也是B+Treee索引结构。Innodb的索引文件本身就是数据文件，即B+Tree的数据域存储的就是实际的数据，这种索引就是聚集索引。这个索引的key就是数据表的主键，因此InnoDB表数据文件本身就是主索引。
        InnoDB的辅助索引数据域存储的也是相应记录主键的值而不是地址，所以当以辅助索引查找时，会先根据辅助索引找到主键，再根据主键索引找到实际的数据。所以Innodb不建议使用过长的主键，否则会使辅助索引变得过大。
        建议使用自增的字段作为主键，这样B+Tree的每一个结点都会被顺序的填满，而不会频繁的分裂调整，会有效的提升插入数据的效率。
        上图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。
        而且，与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。
        因此，过程为：将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用”where id = 13”这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。

</pre>
</body>
</html>