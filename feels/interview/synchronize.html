<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<pre>
    1.synchronized的原理：
        在jvm底层，有两个指令 monitorenter、monitorexi
        Synchronizeds是由JVM实现的一种互斥同步的方式，在底层synchronized修饰过的代码回生成 monitorenter、monitorexi两个指令，
        执行到enter时，去获取对象的锁，如果没有锁定，那么就获取了，并且加计数器1，执行exit就-1，当计数器=0那么就代表锁空闲了，没有谁占有。
        synchronized通过计数器来达到获取锁与释放锁的。
    2.上面提到的获取对象的锁，这个锁是什么，如何确定是对象的？
        锁的本质应该就是一种资源，就是上述两个指令的的一个引用类型的参数。
        synchronized可以修饰不同的对象，1.修饰指定的对象 锁代码块
                                        2.修饰方法，如果是静态方法，表示锁的是类对象，如果是非静态方法，表示锁的是此方法对应的对象
                注意：如果一个对象被锁住，对象内所有的被synchronized修饰的方法都会阻塞。无则不会阻塞。
    3.什么是可重入性，为什么说synchronized是可重入锁？
        1。可重入性的意思是，可给一个资源加多把锁，解决死锁问题
        synchronized是可重入锁，在执行monitorenter会去识别是否享有这个对象锁（而不是已经拥有锁就不去识别了），本质上就是通过这个实现可重入。
    4.死锁？：就是多个线程抢占统一资源且没有抢到。
    充分必要条件：1.互斥：一个资源每次只能被一个进程拥有
                    2.请求与保持条件：进程已经拥有一个资源，还去请求另一个，而另一个已经被其他锁占有，且自己获得的资源不释放。
                    3.不可剥夺条件：进程所获得的资源，在没有使用完成之前，不能被强行夺走，只能主动释放。
                    4.循环条件：若干线程形成首尾相连的局面。
    5.jvm对java的原生锁做了哪些优化？
        jdk6之前Monitor的实现全部基于底层系统的互斥锁来实现，也就是前面释放锁于获取锁的逻辑，
        Java的线程与操作系统d的原生线程对应映射关系，如果要将一个线程进行阻塞或者唤醒都需要操作系统的支持，这就需要从用户态切换到内核态，代价十分昂贵，
        在现代jdk中做了大量优化，一种是自旋锁，就是线程进行阻塞之前先让线程等待一段时间，可能在等待的过程中其他线程已经解锁了，这就避免了从用户态到内核态。

        jvm检测到不同的竞争状态自动切换到不同的锁，这就是升级，降级
        偏向锁（默认）
        轻量级锁
        重量级锁

    6.为什么说synchronized是非公平锁？
        非公平锁表现在获取锁的行为上，并非是按照申请锁的时间分配，无论来的早晚，都有同样的机会获取锁，这样可提升性能，但是回出现线程饥饿现象。
    7.为什么说synchronized是悲观锁？乐观锁是什么？的实现原理？
        因为并发策略是悲观的，不管是否发生竞争，都会上锁，用户态与核心态转换，维护锁、计数器、检查是否有被阻塞的线程都需要唤醒。
        先不管其他，进行操作，如果没有被其他线程征用，那么就操作成功，如果征用了，产生冲突，那就进行一系列操作，补偿措施。这种不需挂起线程的操作成为非阻塞同步
        乐观锁的核心算法是，CAS，比较交换，涉及三个值，预期值，内存值，新值，如果内存值与预期值相同，才将内存值改为新值，具备原子性。
    8.乐观锁一定是好的吗？
        乐观锁避免了悲观锁独占资源的现象，提升了性能，
            缺点：1.只保证一个共享变量具备原子性，如果是多个，那就不行了，互斥锁可满足。
                    2.长时间的自旋，会消耗CPU，带来大量开销。
                    3.ABA现象，如果原来是A，被改成B，又被改成A，会认为没有改变过，这种现象对于依赖过程值得影响很大，可借助版本号处理
    9.与synchronized相比，可重入锁reentrantLock得实现原理有何不同？
        synchronized是通过内核标记来区分 JVM实现，而另一个是jdk实现都是通过一个被volitile修饰的int值实现，保证每个线程都这个int值具备可见性与原子性。AQS框架
</pre>
</body>
</html>