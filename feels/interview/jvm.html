<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>something about jvm</title>
</head>
<body>
<pre>
    something about jvm:
    1、Java运行时数据区：
    2、JMM Java内存模型：
    3、堆的内存划分：
    4、GC垃圾回收：
    5、HotSpot 虚拟机详解：
    6、JVM优化：
    7、类加载机制：

    Java虚拟机在执行Java程序的过程中会将其管理的内存划分为若干个不同的数据区域，这些区域有各自的用途、创建和销毁的时间，
    有些区域随虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束来建立和销毁。Java虚拟机所管理的内存包括以下几个运行时数据区域。
    堆、栈、方法区、虚拟机栈、程序计数器。
    JMM Java内存模型：
    1、 Java的并发采用“共享内存”模型，线程之间通过读写内存的公共状态进行通讯。多个线程之间是不能通过直接传递数据交互的，它们之间交互只能通过共享变量实现。
    2、 主要目的是定义程序中各个变量的访问规则。
    3、 Java内存模型规定所有变量都存储在主内存中，每个线程还有自己的工作内存。（1）线程的工作内存中保存了被该线程使用到的变量的拷贝（从主内存中拷贝过来），
    线程对变量的所有操作都必须在工作内存中执行，而不能直接访问主内存中的变量。（2） 不同线程之间无法直接访问对方工作内存的变量，线程间变量值的传递都要通过主内存来完成。
    （3）主内存主要对应Java堆中实例数据部分。工作内存对应于虚拟机栈中部分区域。4、Java线程之间的通信由内存模型JMM（Java Memory Model）控制。
    （1）JMM决定一个线程对变量的写入何时对另一个线程可见。（2）线程之间共享变量存储在主内存中 （3）每个线程有一个私有的本地内存，里面存储了读/写共享变量的副本。
    （4）JMM通过控制每个线程的本地内存之间的交互，来为程序员提供内存可见性保证。
     5、可见性、有序性：（1）当一个共享变量在多个本地内存中有副本时，如果一个本地内存修改了该变量的副本，其他变量应该能够看到修改后的值，此为可见性。
    （2）保证线程的有序执行，这个为有序性。（保证线程安全）
     6、内存间交互操作：（1）lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。
    （2）unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
    （3）read（读取）：作用于主内存变量，把主内存的一个变量读取到工作内存中。
    （4）load（载入）：作用于工作内存，把read操作读取到工作内存的变量载入到工作内存的变量副本中
    （5）use（使用）：作用于工作内存的变量，把工作内存中的变量值传递给一个执行引擎。
    （6）assign（赋值）：作用于工作内存的变量。把执行引擎接收到的值赋值给工作内存的变量。
    （7）store（存储）：把工作内存的变量的值传递给主内存
    （8）write（写入）：把store操作的值入到主内存的变量中
    6.1、注意： （1）不允许read、load、store、write操作之一单独出现
                （2）不允许一个线程丢弃assgin操作
                （3）不允许一个线程不经过assgin操作，就把工作内存中的值同步到主内存中
                （4）一个新的变量只能在主内存中生成
                （5）一个变量同一时刻只允许一条线程对其进行lock操作。但lock操作可以被同一条线程执行多次，只有执行相同次数的unlock操作，变量才会解锁
                （6）如果对一个变量进行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或者assgin操作初始化变量的值。
                （7）如果一个变量没有被锁定，不允许对其执行unlock操作，也不允许unlock一个被其他线程锁定的变量
                （8）对一个变量执行unlock操作之前，需要将该变量同步回主内存中
    堆的内存划分：
        1.新生代，老生代，perm（1.8之后被MetaSpace代替）
        1.新生代使用复清除算法（Copy）：位处新生代的对象，每次GC回收大部分时，新生代分成三份 ,其中eden8:Survivor1:Survivor1，任意一块s未使用，
        将其他两块中存活的对象转移到未使用的Survivor中，清空eden与另一块Survivor。
        Survivor存在的意义：
        如果没有Survivor那么eden每进行一次Minor GC,就会把存活的对象放进老年代，那么老年代很快填满，触发Major GC（一般会触发Minor GC，可称之为Full GC）
        老年代的存储空间远大于新生代，执行时间会很长，那么频发的Full GC会对大型程序的执行与响应速度产生影响，更不要说那些连接了。
        总结：Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。
        为什么要有两个survivor？
        防止发生内存碎片化
        假设只有一个survivor，那么eden触发Minor GC，将存活对象复制到survivor中，下一次eden触发Minor GC，又将对象复制到同一块survivor中，此时survivor中
        也会也会有一些存活的对象，那么回收的对象在前，就会出现，survivor中的储存不连续。如果有两块survivor那么就不会出现这样的情况。
        2.老生代使用标记整理法，因为每次之回收少部分数据。
    GC垃圾回收：
    判断对象是否要回收的方法：可达性分析法 1、1、 可达性分析法：通过一系列“GC Roots”对象作为起点进行搜索，
    如果在“GC Roots”和一个对象之间没有可达路径，则称该对象是不可达的。不可达对象不一定会成为可回收对象。
    进入DEAD状态的线程还可以恢复，GC不会回收它的内存。（把一些对象当做root对象，JVM认为root对象是不可回收的，
    并且root对象引用的对象也是不可回收的） 2、 以下对象会被认为是root对象：（1） 虚拟机栈（栈帧中本地变量表）中引用的对象
    （2） 方法区中静态属性引用的对象 （3） 方法区中常量引用的对象 （4） 本地方法栈中Native方法引用的对象
    3、 对象被判定可被回收，需要经历两个阶段：（1） 第一个阶段是可达性分析，分析该对象是否可达
    （2） 第二个阶段是当对象没有重写finalize()方法或者finalize()方法已经被调用过，虚拟机认为该对象不可以被救活，因此回收该对象。
    （finalize()方法在垃圾回收中的作用是，给该对象一次救活的机会） 4、 方法区中的垃圾回收：（1） 常量池中一些常量、符号引用没有被引用，
    则会被清理出常量池 （2） 无用的类：被判定为无用的类，会被清理出方法区。判定方法如下：A、 该类的所有实例被回收
    B、 加载该类的ClassLoader被回收 C、 该类的Class对象没有被引用 5、 finalize(): （1） GC垃圾回收要回收一个对象的时候，
    调用该对象的finalize()方法。然后在下一次垃圾回收的时候，才去回收这个对象的内存。（2） 可以在该方法里面，指定一些对象在释放前必须执行的操作

    发现虚拟机频繁full GC时应该怎么办：（full GC指的是清理整个堆空间，包括年轻代和永久代）
    （1） 首先用命令查看触发GC的原因是什么 jstat –gccause 进程id （2） 如果是System.gc()，则看下代码哪里调用了这个方法
    （3） 如果是heap inspection(内存检查)，可能是哪里执行jmap –histo[:live]命令 （4） 如果是GC locker，可能是程序依赖的JNI库的原因
    常见的垃圾回收算法：1、Mark-Sweep（标记-清除算法）：（1）思想：标记清除算法分为两个阶段，标记阶段和清除阶段。
    标记阶段任务是标记出所有需要回收的对象，清除阶段就是清除被标记对象的空间。（2）优缺点：实现简单，容易产生内存碎片
    2、Copying（复制清除算法）：（1）思想：将可用内存划分为大小相等的两块，每次只使用其中的一块。当进行垃圾回收的时候了，
    把其中存活对象全部复制到另外一块中，然后把已使用的内存空间一次清空掉。（2）优缺点：不容易产生内存碎片；可用内存空间少；
    存活对象多的话，效率低下。3、Mark-Compact（标记-整理算法）：（1）思想：先标记存活对象，然后把存活对象向一边移动，然后清理掉端边界以外的内存。
    （2）优缺点：不容易产生内存碎片；内存利用率高；存活对象多并且分散的时候，移动次数多，效率低下

    4.分代收集算法：（目前大部分JVM的垃圾收集器所采用的算法）：
    思想：把堆分成新生代和老年代。（永久代指的是方法区）
    （1） 因为新生代每次垃圾回收都要回收大部分对象，所以新生代采用Copying算法。新生代里面分成一份较大的Eden空间和两份较小的Survivor空间。
    每次只使用Eden和其中一块Survivor空间，然后垃圾回收的时候，把存活对象放到未使用的Survivor（划分出from、to）空间中，
    清空Eden和刚才使用过的Survivor空间。（2） 由于老年代每次只回收少量的对象，因此采用mark-compact算法。（3） 在堆区外有一个永久代。
    对永久代的回收主要是无效的类和常量 5、GC使用时对程序的影响？垃圾回收会影响程序的性能，Java虚拟机必须要追踪运行程序中的有用对象，
    然后释放没用对象，这个过程消耗处理器时间 6、几种不同的垃圾回收类型：（1）Minor GC：从年轻代（包括Eden、Survivor区）回收内存。
    A、当JVM无法为一个新的对象分配内存的时候，越容易触发Minor GC。所以分配率越高，内存越来越少，越频繁执行Minor GC
    B、执行Minor GC操作的时候，不会影响到永久代（Tenured）。从永久代到年轻代的引用，被当成GC Roots，从年轻代到老年代的引用在标记阶段直接被忽略掉。
    （2）Major GC：清理整个老年代，当eden区内存不足时触发。（3）Full GC：清理整个堆空间，包括年轻代和老年代。当老年代内存不足时触发。

</pre>
</body>
</html>