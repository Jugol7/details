<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>something about jvm</title>
</head>
<body>
<pre>
    something about jvm:
    1、Java运行时数据区：
    2、JMM Java内存模型：
    3、堆的内存划分：
    4、GC垃圾回收：
    5、HotSpot 虚拟机详解：
    6、JVM优化：
    7、类加载机制：

    Java虚拟机在执行Java程序的过程中会将其管理的内存划分为若干个不同的数据区域，这些区域有各自的用途、创建和销毁的时间，
    有些区域随虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束来建立和销毁。Java虚拟机所管理的内存包括以下几个运行时数据区域。
    堆、栈、方法区、虚拟机栈、程序计数器。

    堆的内存划分：
        1.新生代，老生代，perm（1.8之后被MetaSpace代替）
        1.新生代使用复清除算法（Copy）：位处新生代的对象，每次GC回收大部分时，新生代分成三份 ,其中eden8:Survivor1:Survivor1，任意一块s未使用，
        将其他两块中存活的对象转移到未使用的Survivor中，清空eden与另一块Survivor。
        Survivor存在的意义：
        如果没有Survivor那么eden每进行一次Minor GC,就会把存活的对象放进老年代，那么老年代很快填满，触发Major GC（一般会触发Minor GC，可称之为Full GC）
        老年代的存储空间远大于新生代，执行时间会很长，那么频发的Full GC会对大型程序的执行与响应速度产生影响，更不要说那些连接了。
        总结：Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。
        为什么要有两个survivor？
        防止发生内存碎片化
        假设只有一个survivor，那么eden触发Minor GC，将存活对象复制到survivor中，下一次eden触发Minor GC，又将对象复制到同一块survivor中，此时survivor中
        也会也会有一些存活的对象，那么回收的对象在前，就会出现，survivor中的储存不连续。如果有两块survivor那么就不会出现这样的情况。
        2.老生代使用标记整理法，因为每次之回收少部分数据。
    GC垃圾回收：
    判断对象是否要回收的方法：可达性分析法 1、1、 可达性分析法：通过一系列“GC Roots”对象作为起点进行搜索，
    如果在“GC Roots”和一个对象之间没有可达路径，则称该对象是不可达的。不可达对象不一定会成为可回收对象。
    进入DEAD状态的线程还可以恢复，GC不会回收它的内存。（把一些对象当做root对象，JVM认为root对象是不可回收的，
    并且root对象引用的对象也是不可回收的） 2、 以下对象会被认为是root对象：（1） 虚拟机栈（栈帧中本地变量表）中引用的对象
    （2） 方法区中静态属性引用的对象 （3） 方法区中常量引用的对象 （4） 本地方法栈中Native方法引用的对象
    3、 对象被判定可被回收，需要经历两个阶段：（1） 第一个阶段是可达性分析，分析该对象是否可达
    （2） 第二个阶段是当对象没有重写finalize()方法或者finalize()方法已经被调用过，虚拟机认为该对象不可以被救活，因此回收该对象。
    （finalize()方法在垃圾回收中的作用是，给该对象一次救活的机会） 4、 方法区中的垃圾回收：（1） 常量池中一些常量、符号引用没有被引用，
    则会被清理出常量池 （2） 无用的类：被判定为无用的类，会被清理出方法区。判定方法如下：A、 该类的所有实例被回收
    B、 加载该类的ClassLoader被回收 C、 该类的Class对象没有被引用 5、 finalize(): （1） GC垃圾回收要回收一个对象的时候，
    调用该对象的finalize()方法。然后在下一次垃圾回收的时候，才去回收这个对象的内存。（2） 可以在该方法里面，指定一些对象在释放前必须执行的操作

    发现虚拟机频繁full GC时应该怎么办：（full GC指的是清理整个堆空间，包括年轻代和永久代）
    （1） 首先用命令查看触发GC的原因是什么 jstat –gccause 进程id （2） 如果是System.gc()，则看下代码哪里调用了这个方法
    （3） 如果是heap inspection(内存检查)，可能是哪里执行jmap –histo[:live]命令 （4） 如果是GC locker，可能是程序依赖的JNI库的原因
    常见的垃圾回收算法：1、Mark-Sweep（标记-清除算法）：（1）思想：标记清除算法分为两个阶段，标记阶段和清除阶段。
    标记阶段任务是标记出所有需要回收的对象，清除阶段就是清除被标记对象的空间。（2）优缺点：实现简单，容易产生内存碎片
    2、Copying（复制清除算法）：（1）思想：将可用内存划分为大小相等的两块，每次只使用其中的一块。当进行垃圾回收的时候了，
    把其中存活对象全部复制到另外一块中，然后把已使用的内存空间一次清空掉。（2）优缺点：不容易产生内存碎片；可用内存空间少；
    存活对象多的话，效率低下。3、Mark-Compact（标记-整理算法）：（1）思想：先标记存活对象，然后把存活对象向一边移动，然后清理掉端边界以外的内存。
    （2）优缺点：不容易产生内存碎片；内存利用率高；存活对象多并且分散的时候，移动次数多，效率低下

    4.分代收集算法：（目前大部分JVM的垃圾收集器所采用的算法）：
    思想：把堆分成新生代和老年代。（永久代指的是方法区）
    （1） 因为新生代每次垃圾回收都要回收大部分对象，所以新生代采用Copying算法。新生代里面分成一份较大的Eden空间和两份较小的Survivor空间。
    每次只使用Eden和其中一块Survivor空间，然后垃圾回收的时候，把存活对象放到未使用的Survivor（划分出from、to）空间中，
    清空Eden和刚才使用过的Survivor空间。（2） 由于老年代每次只回收少量的对象，因此采用mark-compact算法。（3） 在堆区外有一个永久代。
    对永久代的回收主要是无效的类和常量 5、GC使用时对程序的影响？垃圾回收会影响程序的性能，Java虚拟机必须要追踪运行程序中的有用对象，
    然后释放没用对象，这个过程消耗处理器时间 6、几种不同的垃圾回收类型：（1）Minor GC：从年轻代（包括Eden、Survivor区）回收内存。
    A、当JVM无法为一个新的对象分配内存的时候，越容易触发Minor GC。所以分配率越高，内存越来越少，越频繁执行Minor GC
    B、执行Minor GC操作的时候，不会影响到永久代（Tenured）。从永久代到年轻代的引用，被当成GC Roots，从年轻代到老年代的引用在标记阶段直接被忽略掉。
    （2）Major GC：清理整个老年代，当eden区内存不足时触发。（3）Full GC：清理整个堆空间，包括年轻代和老年代。当老年代内存不足时触发。

</pre>
</body>
</html>