<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>QuestionLists</title>
</head>
<body>
<pre>
    一、数据结构与算法
        1.常见排序算法及复杂度
            冒泡
            快速
            归并
            选择
            堆
        2.冒泡排序  package com.details.leetcodeandnowcoder.algorithm.BubbleSort
        3.描述链式存储结构：链表存储结构，每个节点存在指针域与数据域，用来存储当前节点的数据与指向下一个数据的引用，双向链表的话，存在前后两个指针指向前后的两个引用。其中在内存中是
                         不连续的，长度可变。克快速插入删除数据，只需将节点的指针引用修改就可，但是查找速度慢，需要遍历链表。而数组需要移动元素。数组查找快，
        4.如何遍历一个二叉树 E:\github\details\src\main\java\com\details\algorithm\tree\ShowTwoTree.java
        5.倒序一个LinkedList SingleLinkedList
        6.递归遍历一个文件夹的所有文件 FileUtils

    二、Java基础

        * 接口与抽象类的区别？
            1.抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。
            2.一般都不实例化，实例化需要实现其为实现的方法
            3.抽象类要被继承。接口要被多实现，接口可继承接口，
            4.抽象类中的方法可有实现的，也可有为实现的，接口中都是为实现的方法，
            5.抽象类中的变量可以有普通变量，接口中都是公共的静态常量(默认的)。
            6.继承抽象类/实现接口 需全部实现抽象方法，如果是抽象类或者接口，可不实现。
            7.抽象类中申明的方法是重构的结果，接口是设计的结果。
            8.抽象类可没有抽象方法，当然有抽象方法的类一定是抽象类，接口可为空的.
            9.抽象类只能单继承，接口可多继承接口，多实现
            10.抽象类与接口中的抽象方法不能定义成static跟private，因为需要被实现。
            11.抽象类用来抽象类别（对象），接口用抽象功能，接口的抽象级别最高

        * Java中的异常有哪几类？分别怎么使用？
            Throwable根——>
                error错误：运行时内部错误或者资源耗尽。OutOfMemoryError，StackOverflowError，会提示用户尽快停止运行。
                exceptions异常：checked(编译时，例如 IO)不改不能运行，runtime(运行时，例如NPE，ClassNotFind)可运行，
            可通过try catch捕获，或者throw，或者在方法上Throws

        * 常用的集合类有哪些？比如List如何排序？详图：https://blog.csdn.net/u010887744/article/details/50575735
            都可以通过Iterator接口遍历迭代
            Collection接口下的子接口为
                List（列表）：有序，可重复，长度可变，查询快，插入删除慢（移动元素）
                    ArrayList：有序可重复，底层数组，查询快，增删慢（需要移动元素），线程不安全，扩容大小为 原来的+原来的 >> 1
                    LinkedList：有序可重复，底层是双向链表，查询慢（需要遍历），增删快，线程不安全
                    还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆 栈、队列和双向队列使用。
                    Vector：有序可重复，底层数组，查询快，增删慢（需要移动元素），线程不安全，效率低，扩容大小为一倍
                Set（集）：无序，不可重复。
                    HashSet：无序，不可重复，底层是Hash表，存取速度快。
                    哈希表存放的是哈希值。HashSet存储元素的顺序并不是按照存入时的顺序（和List显然不 同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。
                    哈希值通过元素的hashcode方法来获取的, HashSet首先判断两个元素的哈希值，如果哈希值一样，接着会比较 equals方法 如果 equls结果为true ，
                    HashSet就视为同一个元素。如果equals为false就不是 同一个元素。此时会形成一个哈希桶。
                    LinkedHashSet：使用链表作为插入顺序，使用Hash表存储，
                    TreeSet：有序，不可重复，底层是NavigableMap extends SortedSet
                Queue：
            Map（映射）：无序，key唯一，可有一个null，value可有多个
                map中几个重要的
                    1.HashMap：key不可重，value可重，可以为null，底层是数组加链表（超过8转换为红黑树）1.8
                    2.TreeMap：key不可重，value可重，底层是二叉树
                    3.HashTable：key跟value都不可重，线程安全
                大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色 的实体是嵌套类 Entry 的实例，
                Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。
                1. capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。
                2. loadFactor：负载因子，默认为 0.75。
                3. threshold：扩容的阈值，等于 capacity * loadFactor
                Java8 对 HashMap 进行了一些修改，大的不同就是利用了红黑树，所以其由 数组+链表+红黑 树 组成。
                根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的 具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，
                时间复杂度取决 于链表的长度，为 O(n)。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后， 会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。
            ConcurrentHashMap
                ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一 些。整个 ConcurrentHashMap 由一个个 Segment 组成，
                Segment 代表”部分“或”一段“的 意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个 segment。
                简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，
                这样只要保证每 个 Segment 是线程安全的，也就实现了全局的线程安全
                Java8 引入了红黑树。

            Dictionary是抽象类，HashTable继承此且实现Map等接口
            所有带有tree与linked都是有序的（插入顺序或者自然顺序）

        * ArrayList和LinkedList内部的实现大致是怎样的？他们之间的区别和优缺点？
            ArrayList底层是数组，自动扩容时，扩容大小为 原来的+原来的 >> 1；查询速度快，增删慢（由于需要移动数组元素的位置）
            LinkedList底层是双向链表，查询慢（需要遍历），增删慢（只需修改节点的前后节点就行）

        * 内存溢出是怎么回事？请举一个例子？
            使用内存过大，导致在运行时，使用的内存比提供的内存大，无法运行，出现内存溢出问题。
                引起内存溢出的原因有很多种，常见的有以下几种：
                　　1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据；
                　　2.集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；
                　　3.代码中存在死循环或循环产生过多重复的对象实体；
                　　4.使用的第三方软件中的BUG；
                　　5.启动参数内存值设定的过小；
        　　java.lang.StackOverflowError
    　　      【原因】：这也内存溢出错误的一种，即线程栈的溢出，要么是方法调用层次过多（比如存在无限递归调用），要么是线程栈太小。
    　　      【解决】：优化程序设计，减少方法调用层次；调整-Xss参数增加线程栈大小

        * ==和equals的区别？
            == 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；
            而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。

        * hashCode方法的作用？
            hashCode： 通过对象的内存地址，经过hash算法得到的一个值，作用是确定对象在内存中的位置，主要使用在集合的数据存储上，例如set中不允许重复的值，
            就是通过hashCode与equals两个方法来确定是否重复的。先hashCode在equals，顺序不可变化。https://www.cnblogs.com/yuyu666/p/9733572.html

        * NIO是什么？适用于何种场景？
            多路复用IO，
            Java New IO，同步阻塞/非阻塞IO

            Channel
            Selector
            Buffer

        * HashMap实现原理，如何保证HashMap的线程安全？
        * JVM内存结构，为什么需要GC？
        * NIO模型，select/epoll的区别，多路复用的原理
        * Java中一个字符占多少个字节，扩展再问int, long, double占多少字节
        * 创建一个类的实例都有哪些办法？
        * final/finally/finalize的区别？
        * Session/Cookie的区别？
        * String/StringBuffer/StringBuilder的区别，扩展再问他们的实现？
        * Servlet的生命周期？
        * 如何用Java分配一段连续的1G的内存空间？需要注意些什么？
        * Java有自己的内存回收机制，但为什么还存在内存泄露的问题呢？
        * 什么是java序列化，如何实现java序列化?(写一个实例)？
        * Java反射：（运行状态中知道类所有的属性和方法）
            在运行中，对于任意一个类我们都可以知道所有的方法与属性，并且对于任意一个对象，我们可调用任意一个方法，这种动态获取信息以及动态调用方法的方式就是反射。
            在Java中一般声明一个对象，会有编译时类型与运行时类型
            例如： A a = new B();  A是编译时类型，B才是运行时类型
            如果编译时根本无法预知该对象和类属于哪些类，程序只能依靠运行时信息来发现该对象 和类的真实信息，此时就必须使用到反射了。
            Class类，核心类，可获取类的属性与方法等信息。
            Field类，Java.lang.reflect包中的类，包含成员变量，可获取或设置类中的属性值。
            Method类，Java.lang.reflect包中的类，包含类的方法，可获取方法的信息及调用方法。
            Constructor类，Java.lang.reflect包中的类，包含类的构造方法。
            三种方式：
                1.Person p = new Person();
                Class c = p.getClass();
                2.Class c = Person.class;
                3.Class c = Class.forName("全路径");
            此时就可以通过 c 获取方法与属性等信息了。


        * String s = new String("abc");创建了几个 String Object?

    三、JVM
        * JVM堆的基本结构。
        * JVM的垃圾算法有哪几种？CMS垃圾回收的基本流程？
        * JVM有哪些常用启动参数可以调整，描述几个？
        * 如何查看JVM的内存使用情况？
        * Java程序是否会内存溢出，内存泄露情况发生？举几个例子。
        * 你常用的JVM配置和调优参数都有哪些？分别什么作用？
        * JVM的内存结构？
        * 常用的GC策略，什么时候会触发YGC，什么时候触发FGC？

    四、多线程/并发
        * 如何创建线程？如何保证线程安全？
        * 如何实现一个线程安全的数据结构
        * 如何避免死锁
        * Volatile关键字的作用？
        * HashMap在多线程环境下使用需要注意什么？为什么？
        * Java程序中启动一个线程是用run()还是start()？
        * 什么是守护线程？有什么用？
        * 什么是死锁？如何避免
        * 线程和进程的差别是什么？
        * Java里面的Threadlocal是怎样实现的？
        * ConcurrentHashMap的实现原理是？
        * sleep和wait区别
        * notify和notifyAll区别
        * volatile关键字的作
        * ThreadLocal的作用与实现
        * 两个线程如何串行执行
        * 上下文切换是什么含义
        * 可以运行时kill掉一个线程吗？
        * 什么是条件锁、读写锁、自旋锁、可重入锁？
        * 线程池ThreadPoolExecutor的实现原理？

    五、Linux使用与问题分析排查
        * 使用两种命令创建一个文件？
        * 硬链接和软链接的区别？
        * Linux常用命令有哪些？
        * 怎么看一个Java线程的资源耗用？
        * Load过高的可能性有哪些？
        * /etc/hosts文件什么做用？
        * 如何快速的将一个文本中所有“abc”替换为“xyz”？
        * 如何在log文件中搜索找出error的日志？
        * 发现磁盘空间不够，如何快速找出占用空间最大的文件？
        * Java服务端问题排查（OOM，CPU高，Load高，类冲突）
        * Java常用问题排查工具及用法（top, iostat, vmstat, sar, tcpdump, jvisualvm, jmap, jconsole）
        * Thread dump文件如何分析（Runnable，锁，代码栈，操作系统线程ID关联）
        * 如何查看Java应用的线程信息？

    六、框架使用
        * 描述一下Hibernate的三个状态？
        * Spring中Bean的生命周期。
        * SpringMVC或Struts处理请求的流程。
        * Spring AOP解决了什么问题？怎么实现的？
        * Spring事务的传播属性是怎么回事？它会影响什么？
        * Spring中BeanFactory和FactoryBean有什么区别？
        * Spring框架中IOC的原理是什么？
        * spring的依赖注入有哪几种方式
        * struts工作流程
        * 用Spring如何实现一个切面？
        * Spring 如何实现数据库事务？
        * Hibernate对一二级缓存的使用，Lazy-Load的理解；
        * mybatis如何实现批量提交？

    七、数据库相关
        * MySQL InnoDB、Mysaim的特点？
        * 乐观锁和悲观锁的区别？
        * 数据库隔离级别是什么？有什么作用？
        * MySQL主备同步的基本原理。
        * select * from table t where size > 10 group by size order by size的sql语句执行顺序？
        * 如何优化数据库性能（索引、分库分表、批量操作、分页算法、升级硬盘SSD、业务优化、主从部署）
        * SQL什么情况下不会使用索引（不包含，不等于，函数）
        * 一般在什么字段上建索引（过滤数据最多的字段）
        * 如何从一张表中查出name字段不包含“XYZ”的所有行？
        * MySQL，B+索引实现，行锁实现，SQL优化

        * Redis，RDB和AOF，如何做高可用、集群
            Redis：一个基于K-V的内存数据库，类似memcached，不过数据了持久化，且支持丰富的数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。
            redis所有的数据都保存在内存中，不定期保存到磁盘上（半持久化模式），也可把所有数据变化都写到一个aof（append of file 全持久化）中
            常用于缓存，分布式等，但是内存数据变化快，容易丢失。，如果没有持久化，服务重启数据就会丢失，所以需要开启持久化。
            故此Redis提供了两种持久化机制
            持久化的大致流程: 客户端向服务端发送写操作（数据在客户端的内存中），数据库服务端接收到写请求的数据（服务端的内存），服务端调用write，将数据往磁盘中写。
            RDB：按照指定时间间隔执行数据集的时间点快照，实际操作为一个fork子程序，先将数据集写入临时文件，成功后，替换之前的文件，用二进制压缩。
                优势：1. RDB是比较紧凑的文件时间点，非常适合备份。
                      2. 例如，可以每天拍一次快照，在这一天当中可每个小时存档一份RDB，这样就可以恢复到指定的版本时间点，
                      3. 对灾难恢复很管用，因为这是一个紧凑的文件，可传输到远程数据中心。
                      4. 最大程度的提高了Redis的性能，因为Redis父进程唯一要做的就是分出一个子进程，所有的工作都由子进程完成，父进程将永远不会执行磁盘I / O或类似操作。
                劣势：1. 如果需要最大程度的保证数据的完整性，减少数据丢失的情况。那么RDB不太适合，因为在创建快照的时间段之中数据的更新不会记录，在没有正常关闭的情况，会丢失最新的数据。
                      2. RDB需要使用fork程序，才能使得子程序进行持久化到磁盘，如果数据集很大，那么fork会非常耗时，此基础上 CPU 性能不佳，可能会导致客户端服务的几毫秒短暂的停止。
                Redis会将数据集的快照dump到dump.rdb文件中。此外，我们也可以通过配置文件来修改Redis服务器dump快照的频率，在打开6379.conf文件之后，我们搜索save，可以看到下面的配置信息：
                save 900 1              #在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。
                save 300 10            #在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。
                save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。

            AOF：服务器会记录每一个写入操作(追加的方式)，当服务器重启时，会按照此日志文件进行恢复。
                优势：1，aof机制更安全，持久化更强，通过三种不同的策略，每秒同步，每修改同步，不同步，每秒同步是异步的，效率非常高，如果出现意外宕机，那么也只是丢失那一秒钟的数据，修改同步
                      就是同步持久化，效率比较低，
                      2. aof是append模式写入aof文件的，即便在写入的文件的过程中出现宕机的情况，也不会破坏文件原来的数据，此外还可以通过redis-check-aof来解决数据完整性的问题。
                      3. 如果日志过大，Redis会自动启动rewrite机制，这种机制是安全的，还是以append模式不断写入数据到旧文件中，同时创建一个新的文件记录期间生成的记录，切换后，将数据append到新的。
                      4. aof包含一个格式清晰，易于理解的日志文件用于记录所有修改的操作。可以通过此文件来重建。
                        在Redis的配置文件中存在三种同步方式，它们分别是：
                        appendfsync always     #每次有数据修改发生时都会写入AOF文件。 非常慢，但是安全。
                        appendfsync everysec  #每秒钟同步一次，该策略为AOF的缺省策略。 速度足够块（在2.4中可能跟快照一样），如果发生灾难，可能会丢失1秒的数据。
                        appendfsync no          #从不同步。高效但是数据不会被持久化。  很快，但不安全。
                劣势：1. 对于同一数据集，AOF比RDB大，可能会有许多重复的命令
                      2. 根据确切的同步策略，AOF比RDB慢
                      3. AOF过去发生过这样的bug：因为个别命令的原因，导致AOF文件在重新载入时，无法将数据集恢复成保存时的原样。举个例子，阻塞命令 BRPOPLPUSH。测试套件里为这种情况添加了测试：
                        它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种bug在AOF文件中并不常见，但是对比来说， RDB 几乎是不可能出现这种 bug 的。

        * 如何解决高并发减库存问题
        * mysql存储引擎中索引的实现机制；
        * 数据库事务的几种粒度；
        * 行锁，表锁；乐观锁，悲观锁

    八、网络协议和网络编程
        * TCP建立连接的过程。
        * TCP断开连接的过程。
        * 浏览器发生302跳转背后的逻辑？
        * HTTP协议的交互流程。HTTP和HTTPS的差异，SSL的交互流程？
        * Rest和Http什么关系？ 大家都说Rest很轻量，你对Rest风格如何理解？
        * TCP的滑动窗口协议有什么用？讲讲原理。
        * HTTP协议都有哪些方法？
        * 交换机和路由器的区别？
        * Socket交互的基本流程？
        * http协议（报文结构，断点续传，多线程下载，什么是长连接）
        * tcp协议（建连过程，慢启动，滑动窗口，七层模型）
        * webservice协议（wsdl/soap格式，与rest协议的区别）
        * NIO的好处，Netty线程模型，什么是零拷贝

    九、Redis等缓存系统/中间件/NoSQL/一致性Hash等
        * 列举一个常用的Redis客户端的并发模型。
        * HBase如何实现模糊查询？
        * 列举一个常用的消息中间件，如果消息要保序如何实现？
        * 如何实现一个Hashtable？你的设计如何考虑Hash冲突？如何优化？
        * 分布式缓存，一致性hash
        * LRU算法，slab分配，如何减少内存碎片
        * 如何解决缓存单机热点问题
        * 什么是布隆过滤器，其实现原理是？ False positive指的是？
        * memcache与redis的区别
        * zookeeper有什么功能，选举算法如何进行
        * map/reduce过程，如何用map/reduce实现两个数据源的联合统计

    十、设计模式与重构
        * 你能举例几个常见的设计模式
        * 你在设计一个工厂的包的时候会遵循哪些原则？
        * 你能列举一个使用了Visitor/Decorator模式的开源项目/库吗？
        * 你在编码时最常用的设计模式有哪些？在什么场景下用？
        * 如何实现一个单例？
        * 代理模式（动态代理）
        * 单例模式（懒汉模式，并发初始化如何解决，volatile与lock的使用）
        * JDK源码里面都有些什么让你印象深刻的设计模式使用，举例看看？


</pre>
</body>
</html>