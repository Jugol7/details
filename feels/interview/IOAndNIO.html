<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Java IO/NIO</title>
</head>
<body>
<pre>
    Java IO
    1.阻塞IO模型：
    解释：最传统的一种方式，在读写数据时，出现阻塞现象，当发出IO请求，内核去查看数据是否准备就绪，数据没有就绪，此时用户线程处于阻塞状态；
    数据就绪之后，进行拷贝到用户线程，并返回结果，用户才能解除block状态，例如 socket.read()如果数据没有就绪会一致处在阻塞状态。
    2.非阻塞IO模型：
    解释：当用户线程发起read()操作之后，无需等待就立即会获取一个结果，如果时error，那么就是数据还没就绪，于是就会再次read()操作，当数据就绪，
    就会将数据拷贝到用户线程并返回，这种类型的IO，不断的请求操作，不会释放CPU，一直占用CPU，
    while(true){
        data = socket.read();
        if(data!= error){
        处理数据
        break;
    }}
    while循环会大量占用CPU，所以很少使用
    3.多路IO复用（Java NIO）
    解释：在多路IO模型中，会有一个线程去轮询socket的状态，只有真正有读写事件时，才真正的去调用实际中的IO读写操作，所以在这种模型下，只需要一个线程去管理
    多个socket，系统无需新建线程，也不必维护，只有在真正有socket读写事件时，才使用IO资源，可大大减少资源占用，在Java NIO中，通过selector.select()去查询
    每个通道是否有到达事件，如果没有，那么会一直阻塞，因此这种情况会导致用户线程阻塞，NIO模式，通过一个线程管理多个socket，只有当socket真正有读写时，才
    去占用资源，所以NIO适用于连接数比较多的情况。
    另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态时通过用户线程去进行的，而在多路复用 IO 中，
    轮询每个 socket 状态是内核在进行的，这个效率要比用户线程要高的多。
    不过要注意的是，多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用 IO 模型来说，
    一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。
    4.信号驱动IO模型
    此模型中，用户线程发起一个IO请求，会给对应的socket一个信号函数，用户线程继续执行，当内核数据就绪会发送一个信号给用户线程，用户线程接收到信号之后
    便在信号函数中调用IO读写进行IO请求操作。
    5.异步IO模型
    异步IO模型时最理想的IO模型，用户线程发送IO请求后，就不管了，做自己的事，不会对用户线程产生任何block，内核着手准备数据，一旦准备好了，就给用户线程
    发送一个信号，read完成了。
    总之，异步IO两个步骤都不会阻塞，都是由内核完成，发送信号给用户线程说明完成read操作，用户线程无需再次调用IO请求进行读写，而信号驱动需要用用户线程
    去调用IO请请求进行读写，异步IO只需要发送一次IO请求即可，其他的由内核完成。
    <h3>注意，异步 IO 是需要操作系统的底层支持，在 Java 7 中，提供了 Asynchronous IO。</h3>
</pre>
</body>
</html>